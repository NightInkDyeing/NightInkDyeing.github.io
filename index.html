<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>染墨の小窝</title><meta name="author" content="染墨"><meta name="description" content="憋了俩月不知道写啥 想了三天凑两句废话 --有字就行"><meta name="keywords" content="HTML CSS JavaScript Vue Hexo"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><link rel="icon" href="/images/cs.jpg"><script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css"><link rel="stylesheet" href="/css/fonts.min.css"><script>const mixins={}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script><script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"><script src="/js/lib/highlight.js"></script><script src="/js/lib/preview.js"></script><script src="/js/lib/home.js"></script><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="layout"><transition name="fade"><div id="loading" v-show="loading"><div id="loading-circle"><h2>LOADING</h2><p>加载过慢请开启缓存&ensp;浏览器默认开启</p><img src="/images/loading.gif"></div></div></transition><transition name="into"><div id="main" v-show="!loading"><nav id="menu" ref="menu"><div class="desktop-menu"><a class="title" href="/"><span>染墨の小窝</span> </a><a href="/"><i class="fa-solid fa-house fa-fw"></i> <span>&ensp;Home</span> </a><a href="/about"><i class="fa-solid fa-id-card fa-fw"></i> <span>&ensp;About</span> </a><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> <span>&ensp;Archives</span> </a><a href="/categories"><i class="fa-solid fa-bookmark fa-fw"></i> <span>&ensp;Categories</span> </a><a href="/tags"><i class="fa-solid fa-tags fa-fw"></i> <span>&ensp;Tags</span></a></div><div id="mobile-menu"><div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div><div class="title" @click="showMenu = !showMenu"><i class="fa-solid fa-bars fa-fw"></i> <span>&emsp;染墨の小窝</span></div><transition name="slide"><div class="items" v-show="showMenu"><a href="/"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-house fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Home</div></div></a><a href="/about"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-id-card fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">About</div></div></a><a href="/archives"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-box-archive fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Archives</div></div></a><a href="/categories"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-bookmark fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Categories</div></div></a><a href="/tags"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-tags fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Tags</div></div></a></div></transition></div></nav><div id="home-head"><div id="home-background" ref="homeBackground" data-image="/images/2233.jpg"></div><div id="home-info" @click="homeClick"><span class="loop"></span> <span class="loop"></span> <span class="loop"></span> <span class="loop"></span> <span class="info"><div class="wrap"><h1>染墨の小窝</h1><h3>摆烂× 灵活奋斗√</h3><h5>憋了俩月不知道写啥 想了三天凑两句废话 --有字就行</h5></div></span></div></div><div id="home-posts-wrap" ref="homePostsWrap"><div id="home-posts"><div id="posts"><div class="post"><a href="/2023/03/30/Vue%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%8C%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1/"><h2 class="post-title">Vue中导入包及使用路由</h2></a><div class="category-and-date"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2023/3/30</span></div><div class="description"><div class="content" v-pre><h1 id="0-导入自定义的包"><a href="#0-导入自定义的包" class="headerlink" title="0.导入自定义的包"></a>0.导入自定义的包</h1><p>对于本地的自定义的包，可以直接根据路径导入使用</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><h3 id="import（模块、文件）引入方式"><a href="#import（模块、文件）引入方式" class="headerlink" title="import（模块、文件）引入方式"></a>import（模块、文件）引入方式</h3><h5 id="1-引入第三方插件"><a href="#1-引入第三方插件" class="headerlink" title="1.引入第三方插件"></a>1.引入第三方插件</h5><p>​ <code>import echarts from &#39;echarts&#39;</code></p><h5 id="2-导入CSS文件"><a href="#2-导入CSS文件" class="headerlink" title="2.导入CSS文件"></a>2.导入CSS文件</h5><p>​ <code>import &#39;iview/dist/styles/iview.css&#39;;</code></p><p>​ 如果css文件在.vue文件中</p><p>​ <code>&lt;style&gt;</code></p><p>​ <code>@import &#39;./test.css&#39;;</code></p><p>​ <code>&lt;/style&gt;</code></p><h5 id="3-导入组件"><a href="#3-导入组件" class="headerlink" title="3.导入组件"></a>3.导入组件</h5><p>​ <code>import name1 from &#39;./name1&#39;</code><br>​ <code>import name2 from &#39;./name2&#39;</code></p><pre><code>  `components:&#123;name1,name2,&#125;,`
</code></pre><h5 id="4-import-‘-…’-的语句"><a href="#4-import-‘-…’-的语句" class="headerlink" title="4.import ‘@…’ 的语句"></a>4.import ‘@…’ 的语句</h5><p>​ @ 等价于 /src 这个目录，避免写麻烦又易错的相对路径</p><h5 id="5-引入工具类"><a href="#5-引入工具类" class="headerlink" title="5.引入工具类"></a>5.引入工具类</h5><ul><li><p>第一种是引入单个方法</p><p><code>import &#123;axiosfetch&#125; from &#39;./util&#39;;</code></p><p>下面是写法，需要export导出<br><code>export function axiosfetch(options) &#123;</code></p><p><code>&#125;</code></p></li><li><p>第二种 导入成组的方法</p><p><code>import * as tools from &#39;./libs/tools&#39;</code></p><p>其中tools.js中有多个export方法,把tools里所有export的方法导入</p><p>vue中使用<br><code>Vue.prototype.$tools = tools</code><br>直接用 this.$tools.method调用就可以了</p></li><li><p><strong>PS：export 和 export default的区别</strong></p><p>export：<br><code>import &#123;axiosfetch&#125; from &#39;./util&#39;; //需要加花括号 可以一次导入多个也可以一次导入一个，但都要加括号</code><br><code>如果是两个方法 import &#123;axiosfetch,post&#125; from &#39;./util&#39;;</code></p><p>export default ：<br><code>import axiosfetch from &#39;./util&#39;; //不需要加花括号 只能一个一个导入</code></p></li></ul></li><li><h3 id="export-import和export-default的关系"><a href="#export-import和export-default的关系" class="headerlink" title="export,import和export default的关系"></a>export,import和export default的关系</h3><p>1.export与export default均可用于导出常量、函数、文件、模块等<br>2.在一个文件或模块中，export、import可以有多个，export default仅有一个<br>3.通过export方式导出，在导入时要加{ }，export default则不需要{ }</p></li><li><h3 id="import引入文件路径"><a href="#import引入文件路径" class="headerlink" title="import引入文件路径"></a>import引入文件路径</h3><p>import引入一个依赖包，不需要相对路径。如：</p><p><code>import app from ‘app’;</code><br>import 引入一个自己写的js文件，是需要相对路径的。如：<code>import app from ‘./app.js’;</code></p></li><li><h3 id="import引入文件变量名"><a href="#import引入文件变量名" class="headerlink" title="import引入文件变量名"></a>import引入文件变量名</h3><h5 id="1-使用export抛出的变量需要用-进行import"><a href="#1-使用export抛出的变量需要用-进行import" class="headerlink" title="1.使用export抛出的变量需要用{}进行import"></a>1.使用export抛出的变量需要用{}进行import</h5></li></ul><p>​ <code>export const str = &quot;blablabla~&quot;; ​ export function log(sth) &#123; ​ return sth; ​ &#125;</code></p><p>​ 对应的导入方式：</p><p>​ <code>import &#123; str, log as _log &#125; from &#39;a&#39;;</code></p><p>​ <code>//也可以分开写两次，导入的时候带花括号。还可以用as重命名</code></p><h5 id="2-使用export-default抛出的变量，只需要自己起一个名字就行"><a href="#2-使用export-default抛出的变量，只需要自己起一个名字就行" class="headerlink" title="2.使用export default抛出的变量，只需要自己起一个名字就行"></a>2.使用export default抛出的变量，只需要自己起一个名字就行</h5><p>​ <code>var obj = &#123; name: ‘example’ &#125;; ​ export default obj;</code></p><p>​ <code>import newNname from ‘./a.js’; //newNname 是自己随便取的名字，这里可以随便命名</code></p><p>​ <code>console.log(newNname .name); // example;</code></p><p>​</p><p>​ <strong>PS：其中export和export default最大的区别就是export不限变量数 可以一直写，而export default 只输出一次 而且 export出的变量想要使用必须使用{}来盛放，而export default 不需要 只要import任意一个名字来接收对象即可</strong></p><ul><li><h3 id="部分导入和部分导出，全部导入和全部导出"><a href="#部分导入和部分导出，全部导入和全部导出" class="headerlink" title="部分导入和部分导出，全部导入和全部导出"></a>部分导入和部分导出，全部导入和全部导出</h3><h5 id="1-部分导出和部分导入"><a href="#1-部分导出和部分导入" class="headerlink" title="1.部分导出和部分导入"></a>1.部分导出和部分导入</h5><p>​ 部分导出和部分导入的优势，当资源比较大时建使用部分导出，这样一来使用者可以使用部分导入来减少资源体积，比如element-ui官方的就推荐使用部分导入来减少项目体积，因为element-ui是一个十分庞大的框架，如果我们只用到其中的一部分组件， 那么只将用到的组件导入就可以了</p><p>​ <code>//部分导出 //A.js export function helloWorld()&#123; conselo.log(&quot;Hello World&quot;); &#125; export function test()&#123; conselo.log(&quot;this&#39;s test function&quot;); &#125;</code></p><p><code>//部分导入 //B.js import &#123;helloWorld&#125; from &quot;./A.js&quot; //只导入A.js中的helloWorld方法 helloWorld(); //执行utils.js中的helloWorld方法</code></p><p>如果我们需要A.js中的全部资源，则可以全部导入</p><p><code>import * as _A from &quot;./A.js&quot; //导入全部的资源，_A为别名，在调用时使用 _A.helloWorld(); //执行A.js中的helloWorld方法 _A.test(); //执行A.js中的test方法</code></p><h5 id="2-全部导出和全部导入"><a href="#2-全部导出和全部导入" class="headerlink" title="2.全部导出和全部导入"></a>2.全部导出和全部导入</h5><p>​ 如果使用全部导出，那么使用者在导入时则必须全部导入，推荐在写方法库时使用部分导出，从而将全部导入或者部分导入的权力留给使用者。</p><p>需要注意的是:一个js文件中可以有多个export，但只能有一个export default</p><p><code>//全部导出 A.js var helloWorld=function()&#123; conselo.log(&quot;Hello World&quot;); &#125; var test=function()&#123; conselo.log(&quot;this&#39;s test function&quot;); &#125; export default&#123; helloWorld, test &#125;</code></p><p><code>//全部导入 B.js import A from &quot;./A.js&quot; A.helloWorld(); A.test();</code></p></li></ul><h1 id="1-导入第三方包"><a href="#1-导入第三方包" class="headerlink" title="1.导入第三方包"></a>1.导入第三方包</h1><p>​ 对于上传在云端的第三包npm i后才能导入使用</p><ul><li><p>npm install 包的名字(简写 npm i )</p></li><li><p>import 导入</p></li><li><p>使用</p><p><strong>PS：导入导出参考自定义包</strong></p></li></ul><h1 id="2-Vue-router的使用"><a href="#2-Vue-router的使用" class="headerlink" title="2.Vue-router的使用"></a>2.Vue-router的使用</h1><ol><li>若想将对应页面加入路由，只需在路由表中注册即可</li><li>最常用的路由方法为push和go</li><li>相对路径只会更改地址的最后一段，而绝对路径则会从根路径开始。</li></ol><ul><li><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.安装</p><p>2.导入路由</p><p>3.注册 Vue-router</p><p>4.设置匹配规则</p><p>5.实例化 router</p><p>6.导出 router</p><p>7.导入路由并挂载在main.js中</p></li><li><h3 id="路由配置顶"><a href="#路由配置顶" class="headerlink" title="路由配置顶"></a>路由配置顶</h3><p>1.path：要请求的hash地址</p><p>2.component：要展示的组件</p><p>3.redirect：重定向，指定一个新的路由地址</p><p>4.children：通过 children 属性，声明嵌套子路由规则</p><p>5.name：配置中给某个路由设置名称</p><p>6.props：路由解耦，路由传参的一种方式，针对动态路由</p><p>7.meta：路由元信息，当前路由所携带的一些信息</p></li><li><h3 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h3><ol><li>vue-router提供了一个全局组件 router-link</li><li>router-link实质上最终会渲染成a链接 to属性等价于提供 href属性(to无需#)</li><li>router-link提供了声明式导航高亮的功能(自带类名)</li><li>写在template标签里，通过标签来触发</li><li>类名区别<ul><li>router-link-exact-active (精确匹配) url中hash值路径, 与href属性值完全相同, 设置此类名</li><li>router-link-active (模糊匹配) url中hash值, 包含href属性值这个路径</li></ul></li></ol></li><li><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>通过调用JavaScript形式的API实现导航的方式</p><p>除了使用<router-link>创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现</router-link></p><p><strong>PS：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push</strong></p><p>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL</p><p>当你点击<router-link>时，这个方法会在内部调用，所以说，点击<router-link :to="...">等同于调用 router.push(…)</router-link></router-link></p><p><strong>PS：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</strong></p><p>同样的规则也适用于 router-link 组件的 to 属性，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录</p><p>router.go(n)方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)</p></li><li><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>通过路由实现组件的嵌套展示，在现有的一级路由下, 再嵌套二级路由</p></li><li><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><p>this.$router.push</p><p>使用path会自动忽略params</p><ul><li>query参数</li><li>params参数</li></ul></li><li><h3 id="route-与-router区别"><a href="#route-与-router区别" class="headerlink" title="route 与 router区别"></a>route 与 router区别</h3><p>$route是路由的参数对象，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。<br>$router是VueRouter的一个对象，通过Vue.use(VueRouter)和Vue构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由，包含了许多关键的对象和属性</p></li><li><h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><p>1.props为对象模式</p><p>​ 值为对象，该对象中的所有key-value都会以props的形式传给组件，配置在哪个路由规则内就传给谁</p><p>2.props为布尔模式</p><p>​ 值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件</p><p>3.props为函数模式</p></li><li><h3 id="vue-router的两种（单页应用）模式"><a href="#vue-router的两种（单页应用）模式" class="headerlink" title="vue-router的两种（单页应用）模式"></a>vue-router的两种（单页应用）模式</h3><ul><li>hash 模式<ul><li>底层原理是通过hashChange 实现，使用 URL 的 hash 来模拟一个完整的 URL, 其显示的网络路径中会有 “#” 号，hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash后刷新, 也不会有问题</li></ul></li><li>history 模式<ul><li>底层原理是通过replaceState(), pushState()实现，history模式就是美化后的hash模式，路径中不包含“#”。依赖于Html5 的 history api 项目打包上线由于改变了地址, 刷新时会按照修改后的地址请求后端, 需要后端配置处理, 将地址访问做映射, 否则会404</li></ul></li></ul></li></ul></div></div><div class="post-tags"></div><a href="/2023/03/30/Vue%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%8C%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1/" class="go-post">阅读全文</a></div><div class="post"><a href="/2023/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"><h2 class="post-title">Vue组件化</h2></a><div class="category-and-date"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2023/3/24</span></div><div class="description"><div class="content" v-pre><h1 id="0-组件化概念"><a href="#0-组件化概念" class="headerlink" title="0.组件化概念"></a>0.组件化概念</h1><p>组件化是一种抽象，它允许我们使用小型、独立和通常可复用的组件构建大型应用，几乎任意类型的应用界面都可以抽象为一个组件树</p><h1 id="1-使用组件化"><a href="#1-使用组件化" class="headerlink" title="1.使用组件化"></a>1.使用组件化</h1><h3 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h3><ul><li>使用entend进行创建</li><li>使用component创建</li><li>entend语法糖</li><li>将template摘出去<h3 id="组件中的Data和Methods（必须是一个对象）"><a href="#组件中的Data和Methods（必须是一个对象）" class="headerlink" title="组件中的Data和Methods（必须是一个对象）"></a>组件中的Data和Methods（必须是一个对象）</h3></li><li>全局注册：全局可用</li><li>局部注册：只是在注册的那一块可以使用<h3 id="单文件组合"><a href="#单文件组合" class="headerlink" title="单文件组合"></a>单文件组合</h3>在一个.vue文件中集成了Html，Css，Js，实现应用中局部功能代码和资源的集合<h3 id="PS：组件名：-1-使用Kebab-case方式-2-使用-PascalCase"><a href="#PS：组件名：-1-使用Kebab-case方式-2-使用-PascalCase" class="headerlink" title="PS：组件名： 1. 使用Kebab-case方式    2. 使用 PascalCase"></a>PS：组件名： 1. 使用Kebab-case方式 2. 使用 PascalCase</h3><h3 id="父子组件中的传值"><a href="#父子组件中的传值" class="headerlink" title="父子组件中的传值"></a>父子组件中的传值</h3><h4 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h4>通过props，父组件传入，子组件通过props接收。<h4 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h4>直接改变父组件的值。<h4 id="emits"><a href="#emits" class="headerlink" title="emits"></a>emits</h4></li><li>推荐使用kebab-case的事件名</li><li>通过绑定自定义事件<h3 id="插槽的使用"><a href="#插槽的使用" class="headerlink" title="插槽的使用"></a>插槽的使用</h3></li><li>插槽中的slot将会和组件标签中插入的元素进行替换， 也可以给slot中添加默认元素</li><li>可以插入文字，组件，标签</li><li>可以给插槽起名字，不起名字默认为default，在一个组件中添加多个插槽</li></ul><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><ul><li>前置问题：编译作用域， 默认只能取到自己的。</li><li>将子组件中的数据绑定到slot标签上，提供接口，在父组件中使用的时候，使用v-slot进行接收</li><li>如果只有默认插槽可以省略插槽名 v-slot=”user”<h3 id="访问元素和组件"><a href="#访问元素和组件" class="headerlink" title="访问元素和组件"></a>访问元素和组件</h3>（尽量避免在vue中手动操作DOM）</li><li>通过 this.$root 获取根组件</li><li>通过 this.$parent 获取父组件</li><li>通过在标签或者组件上添加ref属性来实现绑定，通过this.$refs调用<h3 id="组件的生命周期（每一个vue实例从创建到销毁的过程）"><a href="#组件的生命周期（每一个vue实例从创建到销毁的过程）" class="headerlink" title="组件的生命周期（每一个vue实例从创建到销毁的过程）"></a>组件的生命周期（每一个vue实例从创建到销毁的过程）</h3></li><li>别名：生命周期回调函数、生命周期函数、生命周期钩子</li><li>是Vue在特定时刻帮我们调用的一些特殊名称的函数</li><li>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的<h4 id="beforeCreate-gt-created-gt-beforeMount-gt-mounted-gt-beforeUpdata-gt-updated-gt-beforeDestroy-gt-destroyed"><a href="#beforeCreate-gt-created-gt-beforeMount-gt-mounted-gt-beforeUpdata-gt-updated-gt-beforeDestroy-gt-destroyed" class="headerlink" title="beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted -&gt; beforeUpdata -&gt; updated -&gt; beforeDestroy -&gt; destroyed"></a>beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted -&gt; beforeUpdata -&gt; updated -&gt; beforeDestroy -&gt; destroyed</h4><h4 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h4>通过一个对象代理对另一个对象中属性的操作（读/写），可以更加方便的操作data中的数据<h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4>处理虚拟DOM和真实DOM<h6 id="使用虚拟DOM可以利用js的计算性能来换取操作DOM所消耗的性能"><a href="#使用虚拟DOM可以利用js的计算性能来换取操作DOM所消耗的性能" class="headerlink" title="使用虚拟DOM可以利用js的计算性能来换取操作DOM所消耗的性能"></a>使用虚拟DOM可以利用js的计算性能来换取操作DOM所消耗的性能</h6><h4 id="常用的生命周期钩子"><a href="#常用的生命周期钩子" class="headerlink" title="常用的生命周期钩子"></a>常用的生命周期钩子</h4></li><li>mounted：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作</li><li>beforeDestroy：清除定时器、解绑自定义事件、取消订阅消息等收尾工作</li><li>一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了</li></ul></div></div><div class="post-tags"></div><a href="/2023/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/" class="go-post">阅读全文</a></div><div class="post"><a href="/2023/03/24/%E5%B8%B8%E7%94%A8%E7%9A%84v%E6%8C%87%E4%BB%A4/"><h2 class="post-title">常用的v指令</h2></a><div class="category-and-date"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2023/3/24</span></div><div class="description"><div class="content" v-pre><h1 id="1-内容渲染指令"><a href="#1-内容渲染指令" class="headerlink" title="1.内容渲染指令"></a>1.内容渲染指令</h1><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul><li>v-text=’msg1’<br>将数据源中的数据直接渲染到成为标签的内容</li></ul><p><strong>缺点：v-text会直接覆盖掉标签内本来的值</strong></p><h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title=" :插值表达式"></a>{{}} :插值表达式</h3><p>插值表达式可以添加简单的JS表达式(加减乘除，三元表达式等)，但是不能使用复杂的JS语句</p><h3 id="v-html：可以添加标签-html元素"><a href="#v-html：可以添加标签-html元素" class="headerlink" title="v-html：可以添加标签(html元素)"></a>v-html：可以添加标签(html元素)</h3><h1 id="2-属性绑定指令"><a href="#2-属性绑定指令" class="headerlink" title="2.属性绑定指令"></a>2.属性绑定指令</h1><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>要给标签的属性绑定动态的值，需要在属性前方加上’v-bind:’,也可以简写成’:’</p><ul><li>v-bind:placeholder=”tips”,tips为data中声明的值</li><li>v-bind:style=”{ }” ：代表动态绑定一个样式对象,他的值是一个{}样式对象</li><li>vue提供的模板渲染语法中，还支持JavaScript表达式的运算</li></ul><h1 id="3-事件绑定指令"><a href="#3-事件绑定指令" class="headerlink" title="3.事件绑定指令"></a>3.事件绑定指令</h1><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>原生DOM对象去掉on即可</p><ul><li>v-on:click v-on:input v-on:keyup</li><li>格式：v-on:事件名称=”事件处理函数的名称”</li><li>简写：@事件名称=”事件处理函数的名称”</li></ul><p><strong>绑定的事件可以用小括号进行传参，若无小括号则默认传触发的事件对象(MouseEvent{}),若在有参数的情况下，仍需获取事件对象，可使用$event符号获取事件对象。(@click=”add(n,$event)”)不过开发中不常用</strong></p><h3 id="事件修饰符-加在事件绑定后面"><a href="#事件修饰符-加在事件绑定后面" class="headerlink" title="事件修饰符(加在事件绑定后面)"></a>事件修饰符(加在事件绑定后面)</h3><ul><li>@click.prenvent=”add”: 点击的同时，阻止默认行为(event.preventDefault() )</li><li>form表单提交会默认刷新网页，可以用@submit.prevent阻止</li><li>.stop:阻止事件冒泡</li><li>.capture: 以捕获模式触发当前的事件处理函数</li><li>.once: 绑定的事件只触发一次</li><li>.self: 只有在event.target是当前元素自身时触发事件处理函数<h3 id="按键修饰符-仅用于键盘事件"><a href="#按键修饰符-仅用于键盘事件" class="headerlink" title="按键修饰符(仅用于键盘事件)"></a>按键修饰符(仅用于键盘事件)</h3></li><li>@keyup.enter=””: 仅按下回车键时触发</li><li>@keyup.esc=””: 仅按下esc时触发</li></ul><h1 id="4-双向绑定指令"><a href="#4-双向绑定指令" class="headerlink" title="4.双向绑定指令"></a>4.双向绑定指令</h1><h3 id="双向数据绑定指令-v-model"><a href="#双向数据绑定指令-v-model" class="headerlink" title="双向数据绑定指令:v-model"></a>双向数据绑定指令:v-model</h3><p>只有表单元素才能使用v-model，其他元素或无法呈现内容，或无法修改内容均无法使用该指令<br>表单元素均可使用(可理解为带value属性的标签可用)</p><h4 id="input输入框"><a href="#input输入框" class="headerlink" title="input输入框"></a>input输入框</h4><ul><li>type=”radio”</li><li>type=”checkbox”</li><li>type=”xxxx”<h4 id="textarea文本域"><a href="#textarea文本域" class="headerlink" title="textarea文本域"></a>textarea文本域</h4><h4 id="select下拉菜单"><a href="#select下拉菜单" class="headerlink" title="select下拉菜单"></a>select下拉菜单</h4><h3 id="v-model指令的修饰符"><a href="#v-model指令的修饰符" class="headerlink" title="v-model指令的修饰符"></a>v-model指令的修饰符</h3></li><li>.number:自动将用户输入值转为数值类型</li><li>.trim:自动过滤用户输入的首尾空白字符</li><li>.lazy:在”change”时而非”input”时更新</li></ul><p><strong>中间变化的时候不会同步到data数据源中，只会在最后输入完成后改变</strong></p><h1 id="5-条件渲染指令"><a href="#5-条件渲染指令" class="headerlink" title="5.条件渲染指令"></a>5.条件渲染指令</h1><h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><ul><li>v-if：动态创建和删除元素(页面创建时即为false只有特殊情况才会让其显示时用v-if)</li><li>v-show：为元素添加或删除display:none样式来隐藏或显示元素(频繁切换时建议使用)</li><li><strong>现在电脑对此消耗不大，绝大多数情况无需考虑性能直接使用v-if</strong></li><li>与v-if配合使用的v-else-if()和v-else</li><li><strong>官方建议使用v-for时，后面一定要绑定一个:key=’item.id’(.vue文件中不绑key会直接报错)而且，尽量把id作为key的值</strong></li><li>可提升性能，防止列表状态紊乱</li><li><strong>官方对id的值类型有要求：字符串或数字</strong></li><li><strong>key值不允许重复</strong></li><li>使用索引号index没有用处，因为数组增删改查会改变索引号所对应的数据（如：在数组前面增删数据）</li></ul></div></div><div class="post-tags"></div><a href="/2023/03/24/%E5%B8%B8%E7%94%A8%E7%9A%84v%E6%8C%87%E4%BB%A4/" class="go-post">阅读全文</a></div><div class="post"><a href="/2023/03/24/%E5%88%9D%E8%AF%86Vue/"><h2 class="post-title">初识Vue</h2></a><div class="category-and-date"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2023/3/24</span></div><div class="description"><div class="content" v-pre><h1 id="0-Vue的意义以好处"><a href="#0-Vue的意义以好处" class="headerlink" title="0.Vue的意义以好处"></a>0.Vue的意义以好处</h1><p>Vue是一套框架，是封装好的组件，使用Vue进行开发可以省略一些基本的相同底层代码，提高效率（类比与C++的类√）</p><h1 id="1-Vue框架原理"><a href="#1-Vue框架原理" class="headerlink" title="1.Vue框架原理"></a>1.Vue框架原理</h1><p>vue框架是基于MVVM设计模式的前端框架，其中的Vue对象是MVVM设计模式中的VM视图模型。<br>Vue对象将页面中要改变的元素和data中变量进行绑定，绑定后它会一直监听data中变量值的改变，当值发生改变时，会自动找到与其绑定的元素并且让元素跟着发生改变，改变元素的过程不需要人工干预，提高了开发效率，而且这个过程不需要像 JavaScript 那样频繁DOM操作去改变页面结构，只是监听一片区域，提高了执行效率。</p><h1 id="2-MVVM设计模式"><a href="#2-MVVM设计模式" class="headerlink" title="2.MVVM设计模式"></a>2.MVVM设计模式</h1><ul><li>Model：模型，数据模型 是服务器获取到数据的部分代码</li><li>View：视图，页面部分代码</li><li>VM：视图模型，它会将页面可能发生改变的元素和变量进行绑定，当变量改变时元素的值也会改变，不需要频繁扫描，提高了效率和用户体验<br>简单来说，MVVM就是建立起了Model和View之间的桥梁，对于其中的双向传递操作进行了封装，减少了底层重复代码的书写。（数据的搬运工√）</li></ul><h1 id="3-Vue的基本使用"><a href="#3-Vue的基本使用" class="headerlink" title="3.Vue的基本使用"></a>3.Vue的基本使用</h1><h3 id="Vue的引入方式："><a href="#Vue的引入方式：" class="headerlink" title="Vue的引入方式："></a>Vue的引入方式：</h3><p>Vue框架有两种引入方式，分别是本地引入以及网络引入</p><h3 id="项目结构主要包括："><a href="#项目结构主要包括：" class="headerlink" title="项目结构主要包括："></a>项目结构主要包括：</h3><ul><li>.eslintrc.js，可以通过它来管理你的校验规则</li><li>babel.config.js，可以在开发中使用 JavaScript 的新特性，并且将其转换为在生产环境中可以跨浏览器运行的旧语法代码</li><li>.browserslistrc，可以通过它来控制需要对哪些浏览器进行支持和优化</li><li><strong>public，这个目录包含一些在 Webpack 编译过程中没有加工处理过的文件（有一个例外：index.html 会有一些处理）</strong></li><li>favicon.ico，项目的图标，当前就是一个 Vue 的 logo</li><li>index.html，应用的模板文件，Vue 应用会通过这个 HTML 页面来运行，也可以通过 lodash 这种模板语法在这个文件里插值</li><li><strong>src，这个是 Vue 应用的核心代码目录</strong></li><li>main.js，应用的入口文件。目前它会初始化 Vue 应用并且制定将应用挂载到 index.html 文件中的哪个 HTML 元素上。通常还会做一些注册全局组件或者添额外的 Vue 库的操作</li><li>App.vue， Vue 应用的根节点组件，往下看可以了解更多关注 Vue 组件的信息</li><li>components，用来存放自定义组件的目录，目前里面会有一个示例组件</li><li>assets，这个目录用来存放像 CSS、图片这种静态资源，但是因为它们属于代码目录下，所以可以用 webpack 来操作和处理。<h3 id="Data函数："><a href="#Data函数：" class="headerlink" title="Data函数："></a>Data函数：</h3>data有两种写法，最好采用函数的写法（避免组件复用时，数据存在引用关系导致组件相互间的数据连锁变化），由vue管理的函数不要写成箭头函数，否则this指向的就不是vuecomponent实例对象（当前组件对象）</li></ul><p><strong>一旦data中的数据改变，那么用到该数据的地方也会自动更新</strong></p><h3 id="PS：this指向问题"><a href="#PS：this指向问题" class="headerlink" title="PS：this指向问题"></a>PS：this指向问题</h3><ul><li>vm只有一个，只有vm能指定挂载点，vm掌柜着众多vc，vc是一个个组件实例对象(每次调用- - Vue.extend，都会返回一个不同的vc)，即一个个组件</li><li>在组件中配置的data，methods，watch等，this指向vc</li><li>在new Vue出来的vue实例对象中，data，methods，watch等，this指向vm<h3 id="Methods方法："><a href="#Methods方法：" class="headerlink" title="Methods方法："></a>Methods方法：</h3><h5 id="事件触发的形式"><a href="#事件触发的形式" class="headerlink" title="事件触发的形式"></a>事件触发的形式</h5></li></ul><p><strong>按键触发（keyup，keydown）</strong></p><ul><li>enter，delete（删除和退格键），esc，space，tab，up，down，left，right</li><li>系统修饰键：ctrl，alt，shift，meta</li><li>keyup：按下修饰键，再按下其它键，释放其它键，触发事件</li><li>Vue.config.keyCodes.自定义键名 = 键码</li></ul><p><strong>鼠标触发</strong></p><ul><li>click，mousemove等等<h5 id="事件的内容（methods中定义）"><a href="#事件的内容（methods中定义）" class="headerlink" title="事件的内容（methods中定义）"></a>事件的内容（methods中定义）</h5><h3 id="Computed属性："><a href="#Computed属性：" class="headerlink" title="Computed属性："></a>Computed属性：</h3>计算属性computed是通过data中的已有属性拼凑而成。借助了Object.defineProperty的getter和setter。get初始化和每次computed依赖data中的数据改变时调用。与methods相比，有缓存机制。计算属性最终会出现在vm上，计算属性被修改时，必须写set函数改变data中的依赖数据，进而引起计算属性的变化。<h3 id="Watch属性："><a href="#Watch属性：" class="headerlink" title="Watch属性："></a>Watch属性：</h3>当监视的属性变化，handler自动调用。通过watch配置或$watch监视</li></ul><h1 id="4-Vue的使用方式"><a href="#4-Vue的使用方式" class="headerlink" title="4.Vue的使用方式"></a>4.Vue的使用方式</h1><h3 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h3><ul><li>：插值，定义在标签里，让此处文本内容和变量进行绑定</li><li>v-text=”变量” ：定义在标签中，让元素的文本内容和变量进行绑定</li><li>v-html=”变量”：定义在标签中，让元素的标签内容和变量进行绑定<h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3>让元素属性的值和变量进行单向绑定，当属性值发生变化时变量也发生改变</li><li>结构：v-bind:属性名=“变量”; 或 :属性名=”变量”;<h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3>定义在标签中，让控件的value值和变量进行双向绑定,变量影响页面 同时页面的改动也会影响变</li><li>结构：v-model=”变量”<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3>绑定元素的事件，当条件满足触发时，会触发方法</li><li>如：点击事件(鼠标点击时触发)：v-on:click=”方法” 或 @click=”方法”<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3>让元素显示数量和数组进行绑定，变量数组中每一个对象</li><li>结构：v-for=”(变量,i) in 数组变量” （i 是下标）<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3>让元素的显示状态和变量进行绑定，结果为 true显示，false不显示</li><li>结构：v-if = ”变量“ 和 v-else</li></ul><h1 id="5-Vuex"><a href="#5-Vuex" class="headerlink" title="5.Vuex"></a>5.Vuex</h1><p>对于状态管理，Vuex采用了Flux架构，简单来说，就是遵循单向数据流原则，由用户动作（Action）触发调度者（Dispatcher），由调度者更新存储（store）中的数据，最后由存储通知视图（View）进行更新。用户动作不应越过调度者直接改变存储，调度者也不应影响到视图中的内容。这样使得设计程序的思路清晰，调试时也能快速定位问题所在。</p><h3 id="Vuex的实现"><a href="#Vuex的实现" class="headerlink" title="Vuex的实现"></a>Vuex的实现</h3><ul><li>Action指代用户动作所产生的新数据</li><li>Dispatcher在Vuex中有Actions和Mutations两种实现，Actions应用于对Mutations的包装</li><li>Store为不应被除Mutations以外任何方法更新的数据存储</li><li>View的更新则由Vue.js完成</li></ul><p><strong>PS：初始化Vuex后会自动生成store/index.js</strong></p></div></div><div class="post-tags"></div><a href="/2023/03/24/%E5%88%9D%E8%AF%86Vue/" class="go-post">阅读全文</a></div><div class="post"><a href="/2023/03/23/hello-world/"><h2 class="post-title">Hello World</h2></a><div class="category-and-date"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2023/3/23</span></div><div class="description"><div class="content" v-pre><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p></div></div><div class="post-tags"></div><a href="/2023/03/23/hello-world/" class="go-post">阅读全文</a></div><div class="page-current"><div class="prev"></div><div class="page-index"><span class="current">1</span></div><div class="next"></div></div></div></div><div id="home-card"><div id="card-div"><div class="card-style" style="width:300px"><div class="avatar"><img src="/images/cs.jpg" alt="avatar"></div><div class="name">染墨</div><div class="description"><p>Description<br>…</p></div></div></div></div></div><footer id="footer"><div id="footer-wrap"><div>&copy; 2023 - 2023 染墨の小窝 <span id="footer-icon"><i class="fa-solid fa-font-awesome fa-fw"></i> </span>&commat;染墨</div><div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div></div></footer></div></transition><transition name="fade"><div id="preview" ref="preview" v-show="previewShow"><img id="preview-content" ref="previewContent"></div></transition></div><script src="/js/main.js"></script></body></html>