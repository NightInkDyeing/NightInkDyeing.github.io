<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>Vue中导入包及使用路由 | 染墨の小窝</title><meta name="author" content="染墨"><meta name="description" content="憋了俩月不知道写啥 想了三天凑两句废话 --有字就行"><meta name="keywords" content="HTML CSS JavaScript Vue Hexo"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><link rel="icon" href="/images/cs.jpg"><script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css"><link rel="stylesheet" href="/css/fonts.min.css"><script>const mixins={}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script><script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"><script src="/js/lib/highlight.js"></script><script src="/js/lib/preview.js"></script><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="layout"><transition name="fade"><div id="loading" v-show="loading"><div id="loading-circle"><h2>LOADING</h2><p>加载过慢请开启缓存&ensp;浏览器默认开启</p><img src="/images/loading.gif"></div></div></transition><transition name="into"><div id="main" v-show="!loading"><nav id="menu" ref="menu"><div class="desktop-menu"><a class="title" href="/"><span>染墨の小窝</span> </a><a href="/"><i class="fa-solid fa-house fa-fw"></i> <span>&ensp;Home</span> </a><a href="/about"><i class="fa-solid fa-id-card fa-fw"></i> <span>&ensp;About</span> </a><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> <span>&ensp;Archives</span> </a><a href="/categories"><i class="fa-solid fa-bookmark fa-fw"></i> <span>&ensp;Categories</span> </a><a href="/tags"><i class="fa-solid fa-tags fa-fw"></i> <span>&ensp;Tags</span></a></div><div id="mobile-menu"><div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div><div class="title" @click="showMenu = !showMenu"><i class="fa-solid fa-bars fa-fw"></i> <span>&emsp;染墨の小窝</span></div><transition name="slide"><div class="items" v-show="showMenu"><a href="/"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-house fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Home</div></div></a><a href="/about"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-id-card fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">About</div></div></a><a href="/archives"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-box-archive fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Archives</div></div></a><a href="/categories"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-bookmark fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Categories</div></div></a><a href="/tags"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-tags fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Tags</div></div></a></div></transition></div></nav><div class="article"><div><h1>Vue中导入包及使用路由</h1></div><div class="info"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2023/3/30</span></div><div class="content" v-pre><h1 id="0-导入自定义的包"><a href="#0-导入自定义的包" class="headerlink" title="0.导入自定义的包"></a>0.导入自定义的包</h1><p>对于本地的自定义的包，可以直接根据路径导入使用</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><h3 id="import（模块、文件）引入方式"><a href="#import（模块、文件）引入方式" class="headerlink" title="import（模块、文件）引入方式"></a>import（模块、文件）引入方式</h3><h5 id="1-引入第三方插件"><a href="#1-引入第三方插件" class="headerlink" title="1.引入第三方插件"></a>1.引入第三方插件</h5><p>​ <code>import echarts from &#39;echarts&#39;</code></p><h5 id="2-导入CSS文件"><a href="#2-导入CSS文件" class="headerlink" title="2.导入CSS文件"></a>2.导入CSS文件</h5><p>​ <code>import &#39;iview/dist/styles/iview.css&#39;;</code></p><p>​ 如果css文件在.vue文件中</p><p>​ <code>&lt;style&gt;</code></p><p>​ <code>@import &#39;./test.css&#39;;</code></p><p>​ <code>&lt;/style&gt;</code></p><h5 id="3-导入组件"><a href="#3-导入组件" class="headerlink" title="3.导入组件"></a>3.导入组件</h5><p>​ <code>import name1 from &#39;./name1&#39;</code><br>​ <code>import name2 from &#39;./name2&#39;</code></p><pre><code>  `components:&#123;name1,name2,&#125;,`
</code></pre><h5 id="4-import-‘-…’-的语句"><a href="#4-import-‘-…’-的语句" class="headerlink" title="4.import ‘@…’ 的语句"></a>4.import ‘@…’ 的语句</h5><p>​ @ 等价于 /src 这个目录，避免写麻烦又易错的相对路径</p><h5 id="5-引入工具类"><a href="#5-引入工具类" class="headerlink" title="5.引入工具类"></a>5.引入工具类</h5><ul><li><p>第一种是引入单个方法</p><p><code>import &#123;axiosfetch&#125; from &#39;./util&#39;;</code></p><p>下面是写法，需要export导出<br><code>export function axiosfetch(options) &#123;</code></p><p><code>&#125;</code></p></li><li><p>第二种 导入成组的方法</p><p><code>import * as tools from &#39;./libs/tools&#39;</code></p><p>其中tools.js中有多个export方法,把tools里所有export的方法导入</p><p>vue中使用<br><code>Vue.prototype.$tools = tools</code><br>直接用 this.$tools.method调用就可以了</p></li><li><p><strong>PS：export 和 export default的区别</strong></p><p>export：<br><code>import &#123;axiosfetch&#125; from &#39;./util&#39;; //需要加花括号 可以一次导入多个也可以一次导入一个，但都要加括号</code><br><code>如果是两个方法 import &#123;axiosfetch,post&#125; from &#39;./util&#39;;</code></p><p>export default ：<br><code>import axiosfetch from &#39;./util&#39;; //不需要加花括号 只能一个一个导入</code></p></li></ul></li><li><h3 id="export-import和export-default的关系"><a href="#export-import和export-default的关系" class="headerlink" title="export,import和export default的关系"></a>export,import和export default的关系</h3><p>1.export与export default均可用于导出常量、函数、文件、模块等<br>2.在一个文件或模块中，export、import可以有多个，export default仅有一个<br>3.通过export方式导出，在导入时要加{ }，export default则不需要{ }</p></li><li><h3 id="import引入文件路径"><a href="#import引入文件路径" class="headerlink" title="import引入文件路径"></a>import引入文件路径</h3><p>import引入一个依赖包，不需要相对路径。如：</p><p><code>import app from ‘app’;</code><br>import 引入一个自己写的js文件，是需要相对路径的。如：<code>import app from ‘./app.js’;</code></p></li><li><h3 id="import引入文件变量名"><a href="#import引入文件变量名" class="headerlink" title="import引入文件变量名"></a>import引入文件变量名</h3><h5 id="1-使用export抛出的变量需要用-进行import"><a href="#1-使用export抛出的变量需要用-进行import" class="headerlink" title="1.使用export抛出的变量需要用{}进行import"></a>1.使用export抛出的变量需要用{}进行import</h5></li></ul><p>​ <code>export const str = &quot;blablabla~&quot;; ​ export function log(sth) &#123; ​ return sth; ​ &#125;</code></p><p>​ 对应的导入方式：</p><p>​ <code>import &#123; str, log as _log &#125; from &#39;a&#39;;</code></p><p>​ <code>//也可以分开写两次，导入的时候带花括号。还可以用as重命名</code></p><h5 id="2-使用export-default抛出的变量，只需要自己起一个名字就行"><a href="#2-使用export-default抛出的变量，只需要自己起一个名字就行" class="headerlink" title="2.使用export default抛出的变量，只需要自己起一个名字就行"></a>2.使用export default抛出的变量，只需要自己起一个名字就行</h5><p>​ <code>var obj = &#123; name: ‘example’ &#125;; ​ export default obj;</code></p><p>​ <code>import newNname from ‘./a.js’; //newNname 是自己随便取的名字，这里可以随便命名</code></p><p>​ <code>console.log(newNname .name); // example;</code></p><p>​</p><p>​ <strong>PS：其中export和export default最大的区别就是export不限变量数 可以一直写，而export default 只输出一次 而且 export出的变量想要使用必须使用{}来盛放，而export default 不需要 只要import任意一个名字来接收对象即可</strong></p><ul><li><h3 id="部分导入和部分导出，全部导入和全部导出"><a href="#部分导入和部分导出，全部导入和全部导出" class="headerlink" title="部分导入和部分导出，全部导入和全部导出"></a>部分导入和部分导出，全部导入和全部导出</h3><h5 id="1-部分导出和部分导入"><a href="#1-部分导出和部分导入" class="headerlink" title="1.部分导出和部分导入"></a>1.部分导出和部分导入</h5><p>​ 部分导出和部分导入的优势，当资源比较大时建使用部分导出，这样一来使用者可以使用部分导入来减少资源体积，比如element-ui官方的就推荐使用部分导入来减少项目体积，因为element-ui是一个十分庞大的框架，如果我们只用到其中的一部分组件， 那么只将用到的组件导入就可以了</p><p>​ <code>//部分导出 //A.js export function helloWorld()&#123; conselo.log(&quot;Hello World&quot;); &#125; export function test()&#123; conselo.log(&quot;this&#39;s test function&quot;); &#125;</code></p><p><code>//部分导入 //B.js import &#123;helloWorld&#125; from &quot;./A.js&quot; //只导入A.js中的helloWorld方法 helloWorld(); //执行utils.js中的helloWorld方法</code></p><p>如果我们需要A.js中的全部资源，则可以全部导入</p><p><code>import * as _A from &quot;./A.js&quot; //导入全部的资源，_A为别名，在调用时使用 _A.helloWorld(); //执行A.js中的helloWorld方法 _A.test(); //执行A.js中的test方法</code></p><h5 id="2-全部导出和全部导入"><a href="#2-全部导出和全部导入" class="headerlink" title="2.全部导出和全部导入"></a>2.全部导出和全部导入</h5><p>​ 如果使用全部导出，那么使用者在导入时则必须全部导入，推荐在写方法库时使用部分导出，从而将全部导入或者部分导入的权力留给使用者。</p><p>需要注意的是:一个js文件中可以有多个export，但只能有一个export default</p><p><code>//全部导出 A.js var helloWorld=function()&#123; conselo.log(&quot;Hello World&quot;); &#125; var test=function()&#123; conselo.log(&quot;this&#39;s test function&quot;); &#125; export default&#123; helloWorld, test &#125;</code></p><p><code>//全部导入 B.js import A from &quot;./A.js&quot; A.helloWorld(); A.test();</code></p></li></ul><h1 id="1-导入第三方包"><a href="#1-导入第三方包" class="headerlink" title="1.导入第三方包"></a>1.导入第三方包</h1><p>​ 对于上传在云端的第三包npm i后才能导入使用</p><ul><li><p>npm install 包的名字(简写 npm i )</p></li><li><p>import 导入</p></li><li><p>使用</p><p><strong>PS：导入导出参考自定义包</strong></p></li></ul><h1 id="2-Vue-router的使用"><a href="#2-Vue-router的使用" class="headerlink" title="2.Vue-router的使用"></a>2.Vue-router的使用</h1><ol><li>若想将对应页面加入路由，只需在路由表中注册即可</li><li>最常用的路由方法为push和go</li><li>相对路径只会更改地址的最后一段，而绝对路径则会从根路径开始。</li></ol><ul><li><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.安装</p><p>2.导入路由</p><p>3.注册 Vue-router</p><p>4.设置匹配规则</p><p>5.实例化 router</p><p>6.导出 router</p><p>7.导入路由并挂载在main.js中</p></li><li><h3 id="路由配置顶"><a href="#路由配置顶" class="headerlink" title="路由配置顶"></a>路由配置顶</h3><p>1.path：要请求的hash地址</p><p>2.component：要展示的组件</p><p>3.redirect：重定向，指定一个新的路由地址</p><p>4.children：通过 children 属性，声明嵌套子路由规则</p><p>5.name：配置中给某个路由设置名称</p><p>6.props：路由解耦，路由传参的一种方式，针对动态路由</p><p>7.meta：路由元信息，当前路由所携带的一些信息</p></li><li><h3 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h3><ol><li>vue-router提供了一个全局组件 router-link</li><li>router-link实质上最终会渲染成a链接 to属性等价于提供 href属性(to无需#)</li><li>router-link提供了声明式导航高亮的功能(自带类名)</li><li>写在template标签里，通过标签来触发</li><li>类名区别<ul><li>router-link-exact-active (精确匹配) url中hash值路径, 与href属性值完全相同, 设置此类名</li><li>router-link-active (模糊匹配) url中hash值, 包含href属性值这个路径</li></ul></li></ol></li><li><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>通过调用JavaScript形式的API实现导航的方式</p><p>除了使用<router-link>创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现</router-link></p><p><strong>PS：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push</strong></p><p>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL</p><p>当你点击<router-link>时，这个方法会在内部调用，所以说，点击<router-link :to="...">等同于调用 router.push(…)</router-link></router-link></p><p><strong>PS：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</strong></p><p>同样的规则也适用于 router-link 组件的 to 属性，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录</p><p>router.go(n)方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)</p></li><li><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>通过路由实现组件的嵌套展示，在现有的一级路由下, 再嵌套二级路由</p></li><li><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><p>this.$router.push</p><p>使用path会自动忽略params</p><ul><li>query参数</li><li>params参数</li></ul></li><li><h3 id="route-与-router区别"><a href="#route-与-router区别" class="headerlink" title="route 与 router区别"></a>route 与 router区别</h3><p>$route是路由的参数对象，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。<br>$router是VueRouter的一个对象，通过Vue.use(VueRouter)和Vue构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由，包含了许多关键的对象和属性</p></li><li><h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><p>1.props为对象模式</p><p>​ 值为对象，该对象中的所有key-value都会以props的形式传给组件，配置在哪个路由规则内就传给谁</p><p>2.props为布尔模式</p><p>​ 值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件</p><p>3.props为函数模式</p></li><li><h3 id="vue-router的两种（单页应用）模式"><a href="#vue-router的两种（单页应用）模式" class="headerlink" title="vue-router的两种（单页应用）模式"></a>vue-router的两种（单页应用）模式</h3><ul><li>hash 模式<ul><li>底层原理是通过hashChange 实现，使用 URL 的 hash 来模拟一个完整的 URL, 其显示的网络路径中会有 “#” 号，hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash后刷新, 也不会有问题</li></ul></li><li>history 模式<ul><li>底层原理是通过replaceState(), pushState()实现，history模式就是美化后的hash模式，路径中不包含“#”。依赖于Html5 的 history api 项目打包上线由于改变了地址, 刷新时会按照修改后的地址请求后端, 需要后端配置处理, 将地址访问做映射, 否则会404</li></ul></li></ul></li></ul></div></div><footer id="footer"><div id="footer-wrap"><div>&copy; 2023 - 2023 染墨の小窝 <span id="footer-icon"><i class="fa-solid fa-font-awesome fa-fw"></i> </span>&commat;染墨</div><div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div></div></footer></div></transition><transition name="fade"><div id="preview" ref="preview" v-show="previewShow"><img id="preview-content" ref="previewContent"></div></transition></div><script src="/js/main.js"></script></body></html>